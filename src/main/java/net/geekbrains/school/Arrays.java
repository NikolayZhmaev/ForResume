package net.geekbrains;

public class Arrays {

 /* Написать метод, в который передается не пустой одномерный целочисленный массив, метод должен вернуть true если в
    массиве есть место, в котором сумма левой и правой части массива равны. Примеры: checkBalance([1, 1, 1, || 2, 1]) → true,
    checkBalance ([2, 1, 1, 2, 1]) → false, checkBalance ([10, || 10]) → true, граница показана символами ||, эти
    символы в массив не входят.
*/

    public static boolean balance(int[] mass) {
        int right;  // создаем переменную для помещения в нее правой части массива
        int left;   // создаем переменную для помещения в нее левой части массива
        int leng = mass.length;    //создаем переменную для помещения в нее значения длинны массива.

        for (int i = 0; i < leng - 1; i++) {    /* данный цикл будет базовым. Он будет обходить все порядковые номера
                                                   массива не затрагивая их значений*/
            right = 0;
            left = 0;
            for (int j = 0; j <= i; j++) {  /* данный вложенный цикл будет обходить элементы массива, формируя
                                               левую часть баланса*/
                left += mass[j];
            }
            for (int c = i + 1; c < leng; c++) { /* данный вложенный цикл будет обходить элементы массива, не вошедшие
                                                   в предыдущий цикл и формировать правую часть баланса*/
                right += mass[c];
            }
            if (left == right) {return true;}  /* данный оператор будет проверять условие равенства левой и правой
                                                 частей. В случае выполнения равенства метод возвращает true*/
        }
        return false;
    }

  /* Написать метод, которому на вход подается одномерный массив и число n (может быть положительным, или отрицательным),
     при этом метод должен сместить все элементы массива на n позиций. Для усложнения задачи нельзя пользоваться
     вспомогательными массивами.
  */

    public int[] shifter(int[] array, int value) {

        boolean flag = false; // данная переменная будет отслеживать знак передаваемого значения value
        int lastIndex = array.length - 1; // переменная будет хранить последний индекс переданного массива

        if (value < 0) { // если переданное число будет отрицательным то flag изменим на true
            flag = true;
            value = -value;
        }

        for (int i = 0; i < value; i++) {
            int temp; // переменная будет выполнять роль буффера (сохраняет числа)
            if (flag) {
                temp = array[0];
            } else {
                temp = array[lastIndex];
            }

            for (int j = 0; j < lastIndex; j++) { // данный цикл пробегает по всему массиву, переписывая элементы со сдвигом на 1
                if (flag) {
                    array[j] = array[j + 1];
                } else {
                    array[lastIndex - j] = array[lastIndex - j - 1];
                }
            }

            // после этого записывает элемент из буфера в начало или конец массива, в зависимости от flag
            if (flag) {
                array[lastIndex] = temp;
            } else {
                array[0] = temp;
            }
        }
        return array;
    }

}
